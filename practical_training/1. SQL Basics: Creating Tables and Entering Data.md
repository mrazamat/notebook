# Основы SQL — создание таблиц и ввод данных с использованием Python

**Предмет:** Технологии программирования  
**Специальность:** Компьютерная лингвистика  
**Продолжительность:** 45 минут

---

## 1. Введение: SQL и Python для лингвистических задач

### 1.1 Зачем лингвисту SQL и Python?

В компьютерной лингвистике мы работаем с большими объемами текстовых данных:
- **Корпуса текстов** — миллионы предложений и токенов
- **Словари и лексиконы** — сотни тысяч лексических единиц
- **Аннотации** — морфологический, синтаксический, семантический анализ

**SQL** обеспечивает эффективное хранение и быстрый поиск данных.  
**Python** предоставляет удобный интерфейс для работы с базами данных через библиотеки.

### 1.2 Библиотека sqlite3

Python включает встроенную библиотеку `sqlite3` для работы с SQLite — легковесной СУБД, идеальной для учебных проектов и прототипирования.

**Базовый пример подключения:**
```python
import sqlite3

# Создание/подключение к базе данных
conn = sqlite3.connect('linguistics.db')

# Создание курсора для выполнения SQL-команд
cursor = conn.cursor()

# Закрытие соединения
conn.close()
```

---

## 2. Создание таблиц с помощью Python

### 2.1 Синтаксис CREATE TABLE

**Общая структура SQL-команды:**
```sql
CREATE TABLE table_name (
    column1 datatype constraints,
    column2 datatype constraints,
    ...
);
```

**Основные типы данных в SQLite:**
- `INTEGER` — целые числа
- `REAL` — числа с плавающей точкой
- `TEXT` — текстовые данные
- `BLOB` — бинарные данные
- `NULL` — отсутствие значения

**Ключевые ограничения:**
- `PRIMARY KEY` — уникальный идентификатор строки
- `NOT NULL` — значение обязательно
- `UNIQUE` — все значения уникальны
- `DEFAULT` — значение по умолчанию
- `CHECK` — проверка условия

### 2.2 Пример: Таблица словаря

```python
import sqlite3

conn = sqlite3.connect('linguistics.db')
cursor = conn.cursor()

# Создание таблицы для хранения слов
cursor.execute('''
    CREATE TABLE IF NOT EXISTS words (
        word_id INTEGER PRIMARY KEY AUTOINCREMENT,
        word TEXT NOT NULL UNIQUE,
        lemma TEXT NOT NULL,
        pos TEXT NOT NULL,
        frequency INTEGER DEFAULT 0,
        CHECK (frequency >= 0)
    )
''')

conn.commit()
conn.close()
```

**Пояснения:**
- `IF NOT EXISTS` — создает таблицу только если её ещё нет
- `AUTOINCREMENT` — автоматическая генерация уникального ID
- `CHECK (frequency >= 0)` — частота не может быть отрицательной

### 2.3 Пример: Таблица для корпуса текстов

```python
import sqlite3

conn = sqlite3.connect('linguistics.db')
cursor = conn.cursor()

cursor.execute('''
    CREATE TABLE IF NOT EXISTS texts (
        text_id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT NOT NULL,
        language TEXT DEFAULT 'ru',
        genre TEXT,
        word_count INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
''')

conn.commit()
conn.close()
```

### 2.4 Создание связанных таблиц

**Пример: Тексты и их авторы**

```python
import sqlite3

conn = sqlite3.connect('linguistics.db')
cursor = conn.cursor()

# Таблица авторов
cursor.execute('''
    CREATE TABLE IF NOT EXISTS authors (
        author_id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        birth_year INTEGER
    )
''')

# Таблица текстов со ссылкой на автора
cursor.execute('''
    CREATE TABLE IF NOT EXISTS authored_texts (
        text_id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        content TEXT NOT NULL,
        author_id INTEGER,
        publication_year INTEGER,
        FOREIGN KEY (author_id) REFERENCES authors(author_id)
    )
''')

conn.commit()
conn.close()
```

---

## 3. Добавление данных через Python

### 3.1 Команда INSERT

**Базовый синтаксис:**
```sql
INSERT INTO table_name (column1, column2, ...)
VALUES (value1, value2, ...);
```

### 3.2 Вставка одной записи

```python
import sqlite3

conn = sqlite3.connect('linguistics.db')
cursor = conn.cursor()

# Вставка одного слова
cursor.execute('''
    INSERT INTO words (word, lemma, pos, frequency)
    VALUES (?, ?, ?, ?)
''', ('бежал', 'бежать', 'VERB', 234))

conn.commit()
conn.close()
```

**Важно:** Знак `?` используется как placeholder для предотвращения SQL-инъекций.

### 3.3 Вставка нескольких записей

```python
import sqlite3

conn = sqlite3.connect('linguistics.db')
cursor = conn.cursor()

# Список слов для вставки
words_data = [
    ('кошка', 'кошка', 'NOUN', 456),
    ('быстро', 'быстро', 'ADV', 789),
    ('читает', 'читать', 'VERB', 345),
    ('книгу', 'книга', 'NOUN', 567)
]

# Массовая вставка
cursor.executemany('''
    INSERT INTO words (word, lemma, pos, frequency)
    VALUES (?, ?, ?, ?)
''', words_data)

conn.commit()
print(f"Добавлено {cursor.rowcount} записей")
conn.close()
```

### 3.4 Практический пример: Загрузка корпуса

```python
import sqlite3

def add_text_to_corpus(title, content, language='ru', genre=None):
    """Добавляет текст в корпус"""
    conn = sqlite3.connect('linguistics.db')
    cursor = conn.cursor()
    
    # Подсчет количества слов
    word_count = len(content.split())
    
    cursor.execute('''
        INSERT INTO texts (title, content, language, genre, word_count)
        VALUES (?, ?, ?, ?, ?)
    ''', (title, content, language, genre, word_count))
    
    conn.commit()
    text_id = cursor.lastrowid  # Получаем ID добавленной записи
    conn.close()
    
    return text_id

# Использование функции
text_id = add_text_to_corpus(
    title="Евгений Онегин",
    content="Мой дядя самых честных правил, Когда не в шутку занемог...",
    language="ru",
    genre="poetry"
)

print(f"Текст добавлен с ID: {text_id}")
```

---

## 4. Работа с морфологическими аннотациями

### 4.1 Создание таблицы аннотаций

```python
import sqlite3

conn = sqlite3.connect('linguistics.db')
cursor = conn.cursor()

cursor.execute('''
    CREATE TABLE IF NOT EXISTS morphology (
        morph_id INTEGER PRIMARY KEY AUTOINCREMENT,
        token TEXT NOT NULL,
        lemma TEXT NOT NULL,
        pos TEXT NOT NULL,
        case_form TEXT,
        number_form TEXT,
        gender TEXT,
        sentence_id INTEGER,
        position INTEGER,
        CHECK (position > 0)
    )
''')

conn.commit()
conn.close()
```

### 4.2 Добавление морфологического анализа

```python
import sqlite3

def add_morphological_analysis(sentence_id, tokens_data):
    """
    Добавляет морфологический анализ предложения
    
    tokens_data: список кортежей (token, lemma, pos, case, number, gender, position)
    """
    conn = sqlite3.connect('linguistics.db')
    cursor = conn.cursor()
    
    for token_data in tokens_data:
        cursor.execute('''
            INSERT INTO morphology 
            (token, lemma, pos, case_form, number_form, gender, sentence_id, position)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (*token_data, sentence_id))
    
    conn.commit()
    conn.close()

# Пример использования
sentence_id = 1
analysis = [
    ('Кошка', 'кошка', 'NOUN', 'Nom', 'Sing', 'Fem', 1),
    ('сидела', 'сидеть', 'VERB', None, 'Sing', 'Fem', 2),
    ('на', 'на', 'ADP', None, None, None, 3),
    ('окне', 'окно', 'NOUN', 'Prep', 'Sing', 'Neut', 4)
]

add_morphological_analysis(sentence_id, analysis)
```

---

## 5. Практические упражнения

### Упражнение 1: Создание таблицы биграмм
Биграмма (bigram) — это последовательность из двух соседних элементов (слов, символов или слогов) в тексте, используемая в лингвистике и компьютерной обработке данных (NLP) для анализа частоты их совместного употребления

**Задание:** Создайте таблицу `bigrams` для хранения пар последовательных слов со следующими полями:
- `bigram_id` — первичный ключ с автоинкрементом
- `word1` — первое слово (обязательное)
- `word2` — второе слово (обязательное)
- `frequency` — частота встречаемости (целое число, не меньше 1)
- `corpus` — название корпуса (по умолчанию 'general')

**Решение:**
```python
import sqlite3

conn = sqlite3.connect('linguistics.db')
cursor = conn.cursor()

cursor.execute('''
    CREATE TABLE IF NOT EXISTS bigrams (
        bigram_id INTEGER PRIMARY KEY AUTOINCREMENT,
        word1 TEXT NOT NULL,
        word2 TEXT NOT NULL,
        frequency INTEGER NOT NULL CHECK (frequency >= 1),
        corpus TEXT DEFAULT 'general'
    )
''')

conn.commit()
conn.close()
```

---

### Упражнение 2: Добавление биграмм

**Задание:** Добавьте в таблицу `bigrams` следующие биграммы из литературного корпуса:
- «машинное обучение» — частота 145
- «естественный язык» — частота 203
- «обработка текста» — частота 89

**Решение:**
```python
import sqlite3

conn = sqlite3.connect('linguistics.db')
cursor = conn.cursor()

bigrams_data = [
    ('машинное', 'обучение', 145, 'literary'),
    ('естественный', 'язык', 203, 'literary'),
    ('обработка', 'текста', 89, 'literary')
]

cursor.executemany('''
    INSERT INTO bigrams (word1, word2, frequency, corpus)
    VALUES (?, ?, ?, ?)
''', bigrams_data)

conn.commit()
print(f"Добавлено {cursor.rowcount} биграмм")
conn.close()
```

---

### Упражнение 3: Создание таблиц для параллельного корпуса

**Задание:** Создайте две связанные таблицы:

1. `source_sentences` — исходные предложения:
   - `sentence_id` — первичный ключ
   - `text` — текст предложения
   - `language` — язык (по умолчанию 'ru')

2. `translations` — переводы:
   - `translation_id` — первичный ключ
   - `source_id` — внешний ключ на `source_sentences`
   - `translated_text` — перевод
   - `target_language` — язык перевода (по умолчанию 'en')

**Решение:**
```python
import sqlite3

conn = sqlite3.connect('linguistics.db')
cursor = conn.cursor()

# Таблица исходных предложений
cursor.execute('''
    CREATE TABLE IF NOT EXISTS source_sentences (
        sentence_id INTEGER PRIMARY KEY AUTOINCREMENT,
        text TEXT NOT NULL,
        language TEXT DEFAULT 'ru'
    )
''')

# Таблица переводов
cursor.execute('''
    CREATE TABLE IF NOT EXISTS translations (
        translation_id INTEGER PRIMARY KEY AUTOINCREMENT,
        source_id INTEGER NOT NULL,
        translated_text TEXT NOT NULL,
        target_language TEXT DEFAULT 'en',
        FOREIGN KEY (source_id) REFERENCES source_sentences(sentence_id)
    )
''')

conn.commit()
conn.close()
```

---

### Упражнение 4: Функция для добавления слова в словарь

**Задание:** Напишите функцию `add_word(word, lemma, pos, frequency=0)`, которая добавляет слово в таблицу `words`. Функция должна возвращать `word_id` добавленного слова.

**Решение:**
```python
import sqlite3

def add_word(word, lemma, pos, frequency=0):
    """Добавляет слово в словарь"""
    conn = sqlite3.connect('linguistics.db')
    cursor = conn.cursor()
    
    try:
        cursor.execute('''
            INSERT INTO words (word, lemma, pos, frequency)
            VALUES (?, ?, ?, ?)
        ''', (word, lemma, pos, frequency))
        
        conn.commit()
        word_id = cursor.lastrowid
        return word_id
    
    except sqlite3.IntegrityError as e:
        print(f"Ошибка: {e}")
        return None
    
    finally:
        conn.close()

# Тестирование
word_id = add_word('программирование', 'программирование', 'NOUN', 120)
print(f"Добавлено слово с ID: {word_id}")
```

---

### Упражнение 5: Загрузка данных из списка

**Задание:** Напишите функцию `load_vocabulary_from_list(words_list)`, которая принимает список кортежей `(word, lemma, pos, frequency)` и загружает все слова в таблицу `words`. Функция должна использовать массовую вставку и возвращать количество успешно добавленных записей.

**Решение:**
```python
import sqlite3

def load_vocabulary_from_list(words_list):
    """
    Загружает список слов в базу данных
    
    words_list: список кортежей (word, lemma, pos, frequency)
    Returns: количество добавленных записей
    """
    conn = sqlite3.connect('linguistics.db')
    cursor = conn.cursor()
    
    try:
        cursor.executemany('''
            INSERT INTO words (word, lemma, pos, frequency)
            VALUES (?, ?, ?, ?)
        ''', words_list)
        
        conn.commit()
        count = cursor.rowcount
        return count
    
    except sqlite3.Error as e:
        print(f"Ошибка при загрузке: {e}")
        conn.rollback()
        return 0
    
    finally:
        conn.close()

# Тестирование
vocabulary = [
    ('компьютер', 'компьютер', 'NOUN', 5400),
    ('лингвистика', 'лингвистика', 'NOUN', 890),
    ('анализировать', 'анализировать', 'VERB', 340),
    ('синтаксис', 'синтаксис', 'NOUN', 450)
]

count = load_vocabulary_from_list(vocabulary)
print(f"Загружено {count} слов в словарь")
```

---

## 6. Лучшие практики работы с БД в Python

### 6.1 Использование контекстного менеджера

**Правильный подход с автоматическим закрытием соединения:**

```python
import sqlite3

def get_word_count():
    with sqlite3.connect('linguistics.db') as conn:
        cursor = conn.cursor()
        cursor.execute('SELECT COUNT(*) FROM words')
        count = cursor.fetchone()[0]
        return count
    # Соединение автоматически закрывается

count = get_word_count()
print(f"Всего слов в словаре: {count}")
```

### 6.2 Обработка исключений

```python
import sqlite3

def safe_insert_word(word, lemma, pos):
    try:
        with sqlite3.connect('linguistics.db') as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO words (word, lemma, pos)
                VALUES (?, ?, ?)
            ''', (word, lemma, pos))
            conn.commit()
            return True
    
    except sqlite3.IntegrityError:
        print(f"Слово '{word}' уже существует в базе")
        return False
    
    except sqlite3.Error as e:
        print(f"Ошибка базы данных: {e}")
        return False
```

### 6.3 Параметризованные запросы

**НИКОГДА не делайте так (уязвимость к SQL-инъекциям):**
```python
# ПЛОХО! Опасно!
word = "test"
cursor.execute(f"INSERT INTO words (word) VALUES ('{word}')")
```

**ВСЕГДА используйте параметры:**
```python
# ХОРОШО! Безопасно
word = "test"
cursor.execute("INSERT INTO words (word) VALUES (?)", (word,))
```

### 6.4 Транзакции

```python
import sqlite3

def transfer_words_between_dictionaries(word_ids, from_dict, to_dict):
    """Пример использования транзакций"""
    conn = sqlite3.connect('linguistics.db')
    cursor = conn.cursor()
    
    try:
        # Начало транзакции (автоматически)
        for word_id in word_ids:
            cursor.execute('''
                UPDATE words 
                SET dictionary = ? 
                WHERE word_id = ? AND dictionary = ?
            ''', (to_dict, word_id, from_dict))
        
        # Если всё успешно — фиксируем изменения
        conn.commit()
        print("Транзакция успешно завершена")
    
    except sqlite3.Error as e:
        # При ошибке — откатываем все изменения
        conn.rollback()
        print(f"Транзакция отменена из-за ошибки: {e}")
    
    finally:
        conn.close()
```

---

## 7. Интеграция с библиотеками NLP

### 7.1 Пример с использованием pymorphy2

```python
import sqlite3
import pymorphy2

# Инициализация морфологического анализатора
morph = pymorphy2.MorphAnalyzer()

def analyze_and_store(text, sentence_id):
    """Морфологический анализ и сохранение в БД"""
    conn = sqlite3.connect('linguistics.db')
    cursor = conn.cursor()
    
    tokens = text.split()
    
    for position, token in enumerate(tokens, start=1):
        # Морфологический анализ
        parsed = morph.parse(token)[0]
        
        # Извлечение данных
        lemma = parsed.normal_form
        pos = parsed.tag.POS
        case_form = parsed.tag.case if parsed.tag.case else None
        number = parsed.tag.number if parsed.tag.number else None
        gender = parsed.tag.gender if parsed.tag.gender else None
        
        # Сохранение в БД
        cursor.execute('''
            INSERT INTO morphology 
            (token, lemma, pos, case_form, number_form, gender, sentence_id, position)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (token, lemma, pos, case_form, number, gender, sentence_id, position))
    
    conn.commit()
    conn.close()

# Использование
analyze_and_store("Кошка сидела на окне", sentence_id=1)
```

### 7.2 Построение частотного словаря из текста

```python
import sqlite3
from collections import Counter

def build_frequency_dict_from_text(text):
    """Создает частотный словарь и сохраняет в БД"""
    # Простая токенизация
    words = text.lower().split()
    
    # Подсчет частот
    word_freq = Counter(words)
    
    # Сохранение в БД
    conn = sqlite3.connect('linguistics.db')
    cursor = conn.cursor()
    
    for word, freq in word_freq.items():
        cursor.execute('''
            INSERT OR REPLACE INTO words (word, lemma, pos, frequency)
            VALUES (?, ?, ?, ?)
        ''', (word, word, 'UNKNOWN', freq))
    
    conn.commit()
    conn.close()
    
    print(f"Обработано {len(word_freq)} уникальных слов")

# Пример
sample_text = """
В компьютерной лингвистике мы изучаем естественный язык. 
Естественный язык обрабатывается компьютером.
"""

build_frequency_dict_from_text(sample_text)
```

---

## 8. Контрольные вопросы

### Вопрос 1
**Объясните, почему в Python при работе с SQL-запросами следует использовать параметризованные запросы (с символом `?`) вместо f-строк или конкатенации. Приведите пример уязвимого кода и его безопасную альтернативу.**

**Ответ:**

Параметризованные запросы защищают от SQL-инъекций — атак, при которых злоумышленник может выполнить произвольный SQL-код через пользовательский ввод.

**Уязвимый код:**
```python
user_input = "'; DROP TABLE words; --"
cursor.execute(f"SELECT * FROM words WHERE word = '{user_input}'")
# Результат: таблица будет удалена!
```

**Безопасная альтернатива:**
```python
user_input = "'; DROP TABLE words; --"
cursor.execute("SELECT * FROM words WHERE word = ?", (user_input,))
# Результат: строка воспринимается как данные, а не как код
```

При использовании `?` библиотека sqlite3 автоматически экранирует специальные символы, обрабатывая ввод как данные, а не как SQL-команды. Это обязательная практика безопасности при работе с любыми пользовательскими данными.

---

### Вопрос 2
**В чём разница между методами `execute()` и `executemany()` в sqlite3? В каких ситуациях при работе с лингвистическими данными следует предпочесть `executemany()`? Приведите практический пример.**

**Ответ:**

`execute()` выполняет одну SQL-команду с одним набором параметров:
```python
cursor.execute("INSERT INTO words (word, lemma) VALUES (?, ?)", ('кошка', 'кошка'))
```

`executemany()` выполняет одну SQL-команду многократно с разными наборами параметров:
```python
data = [('кошка', 'кошка'), ('собака', 'собака'), ('птица', 'птица')]
cursor.executemany("INSERT INTO words (word, lemma) VALUES (?, ?)", data)
```

**Когда использовать `executemany()`:**
- При загрузке больших корпусов (тысячи токенов)
- При импорте словарей и лексиконов
- При массовом добавлении морфологических аннотаций
- При парсинге текстовых файлов и добавлении данных в БД

**Преимущества:** `executemany()` значительно быстрее при больших объемах данных (в 10-100 раз), так как использует одну подготовленную инструкцию для всех вставок, минимизирует накладные расходы на транзакции и более эффективно использует память.

**Практический пример:**
```python
# Загрузка 10,000 слов из файла
with open('vocabulary.txt', 'r', encoding='utf-8') as f:
    words_data = [(line.strip(), line.strip(), 'NOUN', 0) for line in f]

cursor.executemany(
    "INSERT INTO words (word, lemma, pos, frequency) VALUES (?, ?, ?, ?)",
    words_data
)
```

---

### Вопрос 3
**Объясните назначение метода `commit()` и метода `lastrowid` в контексте работы с SQLite через Python. Создайте функцию, которая добавляет новый текст в корпус и возвращает его ID для последующего использования.**

**Ответ:**

`commit()` фиксирует изменения в базе данных. До вызова `commit()` все изменения временные и не сохраняются на диск. Это часть механизма транзакций: позволяет откатить изменения при ошибке (`rollback()`), группирует множественные операции в атомарную транзакцию, и обеспечивает целостность данных.

`lastrowid` возвращает ID последней вставленной строки (значение PRIMARY KEY с AUTOINCREMENT). Это полезно для получения автоматически сгенерированного ID и создания связей с другими таблицами.

**Пример функции:**
```python
import sqlite3

def add_text_to_corpus(title, content, language='ru'):
    """
    Добавляет текст в корпус и возвращает его ID
    
    Returns: text_id или None при ошибке
    """
    try:
        with sqlite3.connect('linguistics.db') as conn:
            cursor = conn.cursor()
            
            word_count = len(content.split())
            
            cursor.execute('''
                INSERT INTO texts (title, content, language, word_count)
                VALUES (?, ?, ?, ?)
            ''', (title, content, language, word_count))
            
            # Фиксируем изменения
            conn.commit()
            
            # Получаем ID добавленного текста
            text_id = cursor.lastrowid
            
            print(f"Текст '{title}' добавлен с ID: {text_id}")
            return text_id
    
    except sqlite3.Error as e:
        print(f"Ошибка: {e}")
        return None

# Использование
text_id = add_text_to_corpus(
    "Евгений Онегин", 
    "Мой дядя самых честных правил...",
    "ru"
)

# Теперь можем использовать text_id для добавления аннотаций
if text_id:
    add_annotations(text_id, annotations_data)
```

---

### Вопрос 4
**Что такое внешний ключ (FOREIGN KEY) и как он обеспечивает целостность данных в лингвистических базах? Создайте схему из двух таблиц (предложения и токены) с использованием внешнего ключа и объясните, какие операции будут запрещены СУБД.**

**Ответ:**

Внешний ключ — это ограничение, которое создает связь между таблицами, обеспечивая ссылочную целостность: значение в дочерней таблице должно существовать в родительской таблице.

**Схема базы данных:**
```python
import sqlite3

conn = sqlite3.connect('linguistics.db')
cursor = conn.cursor()

# Родительская таблица: предложения
cursor.execute('''
    CREATE TABLE IF NOT EXISTS sentences (
        sentence_id INTEGER PRIMARY KEY AUTOINCREMENT,
        text TEXT NOT NULL,
        language TEXT DEFAULT 'ru'
    )
''')

# Дочерняя таблица: токены
cursor.execute('''
    CREATE TABLE IF NOT EXISTS tokens (
        token_id INTEGER PRIMARY KEY AUTOINCREMENT,
        token TEXT NOT NULL,
        lemma TEXT NOT NULL,
        pos TEXT,
        sentence_id INTEGER NOT NULL,
        position INTEGER NOT NULL,
        FOREIGN KEY (sentence_id) REFERENCES sentences(sentence_id)
            ON DELETE CASCADE
            ON UPDATE CASCADE
    )
''')

conn.commit()
conn.close()
```

**Операции, которые будут запрещены:**

1. **Вставка токена с несуществующим sentence_id:**
```python
# Если предложения с ID=999 нет, будет ошибка
cursor.execute('''
    INSERT INTO tokens (token, lemma, pos, sentence_id, position)
    VALUES (?, ?, ?, ?, ?)
''', ('слово', 'слово', 'NOUN', 999, 1))
# Ошибка: FOREIGN KEY constraint failed
```

2. **Удаление предложения, на которое ссылаются токены (без CASCADE):**
Если не указан `ON DELETE CASCADE`, нельзя удалить предложение, пока существуют связанные токены.

3. **Изменение sentence_id в родительской таблице (без CASCADE):**
Нельзя изменить ID предложения, если на него ссылаются токены.

**С `ON DELETE CASCADE`:** при удалении предложения автоматически удаляются все связанные токены, что удобно для лингвистических данных — при удалении предложения логично удалить и все его токены.

**Преимущества для лингвистики:**
- Гарантирует, что каждый токен принадлежит существующему предложению
- Предотвращает "осиротевшие" аннотации без исходного текста
- Поддерживает целостность параллельных корпусов
- Обеспечивает каскадное удаление связанных данных

---

### Вопрос 5
**Опишите стратегию обработки ошибок при работе с базой данных в Python. Какие типы исключений может генерировать sqlite3 и как их правильно обрабатывать? Напишите функцию для безопасного добавления слова в словарь с обработкой возможных ошибок.**

**Ответ:**

**Основные типы исключений sqlite3:**

1. `sqlite3.IntegrityError` — нарушение ограничений целостности (PRIMARY KEY, UNIQUE, FOREIGN KEY, CHECK)
2. `sqlite3.OperationalError` — ошибки операций (таблица не существует, синтаксис SQL)
3. `sqlite3.DatabaseError` — общие ошибки базы данных
4. `sqlite3.Error` — базовый класс для всех ошибок sqlite3

**Стратегия обработки:**
- Используйте специфичные исключения для разных сценариев
- Применяйте блоки try-except-finally для гарантированного закрытия соединений
- Используйте контекстные менеджеры (`with`) для автоматического управления ресурсами
- Логируйте ошибки для отладки
- Возвращайте информативные статусы (True/False, ID/None)

**Функция с обработкой ошибок:**
```python
import sqlite3
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def safe_add_word(word, lemma, pos, frequency=0):
    """
    Безопасно добавляет слово в словарь с обработкой ошибок
    
    Returns:
        tuple: (success: bool, word_id: int or None, message: str)
    """
    conn = None
    try:
        conn = sqlite3.connect('linguistics.db')
        cursor = conn.cursor()
        
        # Попытка вставки
        cursor.execute('''
            INSERT INTO words (word, lemma, pos, frequency)
            VALUES (?, ?, ?, ?)
        ''', (word, lemma, pos, frequency))
        
        conn.commit()
        word_id = cursor.lastrowid
        
        logger.info(f"Слово '{word}' успешно добавлено с ID: {word_id}")
        return (True, word_id, "Успешно добавлено")
    
    except sqlite3.IntegrityError as e:
        # Нарушение уникальности или других ограничений
        logger.warning(f"Слово '{word}' уже существует: {e}")
        return (False, None, f"Слово уже существует в словаре")
    
    except sqlite3.OperationalError as e:
        # Проблемы с БД (таблица не существует, синтаксис)
        logger.error(f"Операционная ошибка БД: {e}")
        return (False, None, f"Ошибка операции с БД: {e}")
    
    except sqlite3.DatabaseError as e:
        # Другие ошибки БД
        logger.error(f"Ошибка базы данных: {e}")
        return (False, None, f"Ошибка БД: {e}")
    
    except Exception as e:
        # Неожиданные ошибки
        logger.critical(f"Неожиданная ошибка: {e}")
        return (False, None, f"Неожиданная ошибка: {e}")
    
    finally:
        # Гарантированное закрытие соединения
        if conn:
            conn.close()
            logger.debug("Соединение с БД закрыто")

# Использование
success, word_id, message = safe_add_word('лингвистика', 'лингвистика', 'NOUN', 890)

if success:
    print(f"✓ {message}. ID: {word_id}")
else:
    print(f"✗ {message}")

# Повторная попытка добавить то же слово
success, word_id, message = safe_add_word('лингвистика', 'лингвистика', 'NOUN', 890)
print(f"{'✓' if success else '✗'} {message}")
```

**Лучшие практики:**
- Всегда используйте `try-except-finally` или контекстные менеджеры
- Обрабатывайте специфичные исключения перед общими
- Логируйте ошибки для последующего анализа
- Возвращайте понятные сообщения об ошибках пользователю
- Не раскрывайте детали внутренней структуры БД в сообщениях об ошибках
- Используйте транзакции для атомарных операций

---

## 9. Заключение

В данном докладе мы рассмотрели основы работы с SQL через Python применительно к задачам компьютерной лингвистики:

✓ Создание таблиц с помощью Python и sqlite3  
✓ Добавление данных через INSERT с параметризацией  
✓ Работу с лингвистическими структурами данных  
✓ Лучшие практики безопасности и обработки ошибок  
✓ Интеграцию с библиотеками NLP  

**Ключевые выводы:**
1. Python + SQL = мощный инструментарий для работы с лингвистическими данными
2. Всегда используйте параметризованные запросы для безопасности
3. Применяйте внешние ключи для целостности связанных данных
4. Обрабатывайте исключения для надежности приложений
5. Используйте `executemany()` для массовых операций

**Рекомендуемые библиотеки для дальнейшего изучения:**
- `SQLAlchemy` — ORM для работы с БД на более высоком уровне
- `pandas` — интеграция SQL с анализом данных
- `datasets` (HuggingFace) — работа с большими корпусами
- `pymorphy2`, `spaCy`, `natasha` — морфологический и синтаксический анализ

**Домашнее задание:**  
Создайте базу данных для хранения параллельного корпуса (русский-английский) с морфологическими аннотациями. Реализуйте функции для:
1. Добавления пар предложений
2. Автоматической морфологической разметки (используя pymorphy2 или spaCy)
3. Поиска предложений по лемме
4. Вычисления статистики (количество токенов, частотный словарь)

---

**Спасибо за внимание!**

*Материалы доклада:*  
- Презентация: [ссылка]
- Примеры кода: [GitHub репозиторий]
- Тестовая база данных: linguistics.db